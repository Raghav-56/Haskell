--Recursion is actually a way of defining functions in which the function is applied inside its own definition.
{-
--Definitions in mathematics are often given recursively. 
--For instance, the fibonacci sequence is defined recursively. First, we define the first two fibonacci numbers non-recursively.
We say that F(0) = 0 and F(1) = 1, meaning that the 0th and 1st fibonacci numbers are 0 and 1, respectively. 
Then we say that for any other natural number, that fibonacci number is the sum of the previous two fibonacci numbers. 
So F(n) = F(n-1) + F(n-2).

--Having an element or two in a recursion definition defined non-recursively (like F(0) and F(1) here) is also called the edge condition 
and is important if you want your recursive function to terminate.


-- Recursion is important to Haskell because unlike imperative languages, 
-- you do computations in Haskell by declaring what something is 
-- instead of declaring how you get it. 

--That's why there are no while loops or for loops in Haskell and instead we many times have to use recursion to declare what something is.
-}
















